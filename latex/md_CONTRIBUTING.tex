Thank you for your interest in contributing to the \hyperlink{namespace_vespucci}{Vespucci} Project. These guidelines should help you make a valuable contribution to the project. They cover the process of contributing to \hyperlink{namespace_vespucci}{Vespucci}, the process of adding a spectral pre-\/processing method and the process of adding a spectral analysis method. By following these guidelines, we hope \hyperlink{namespace_vespucci}{Vespucci} can attain a higher degree of quality than other research code.

\section*{Contributing to \hyperlink{namespace_vespucci}{Vespucci} }

The issues page on Git\+Hub includes features we would like to see added to \hyperlink{namespace_vespucci}{Vespucci} that we are currently not working on. If you have a contribution to make, comment on one of these issues (or start your own) and we may assign the issue to you.

If you have code to contribute to \hyperlink{namespace_vespucci}{Vespucci}, simply make a pull request with your changes to the Vespucci\+Project Git\+Hub page. The contribution should include unit tests for at least the functions added to the {\ttfamily \hyperlink{namespace_vespucci_1_1_math}{Vespucci\+::\+Math}} namespace. The pull request will be automatically built by our build service providers, which will execute unit tests (provided you have added them to the Test.\+pro project). The code will be examined for style and quality by the maintainer, and if all tests pass and the contribution is deemed within the mission of the project, your contribution will be integrated into the code base and your name added to our list of contributors. Any code contributed must compile, test, and run successfully on all three of \hyperlink{namespace_vespucci}{Vespucci}\textquotesingle{}s target platforms.

If you have already implemented a method not found in \hyperlink{namespace_vespucci}{Vespucci} in M\+A\+T\+L\+AB or Octave, take a look at the \href{http://arma.sourceforge.net/docs.html#syntax}{\tt syntax conversion table}. Re-\/writing M\+A\+T\+L\+AB code in C++ using Armadillo is fairly easy.

If you are uncomfortable with Qt, but have a meaningful math function to contribute to the library, feel free to make a contribution. The user interface can be created later. Bug fixes and code that improves performance or clarity of existing functions are also welcome.

\section*{Libraries }

Generally, code contributed to the \hyperlink{namespace_vespucci}{Vespucci} project can rely only on the following libraries\+:
\begin{DoxyItemize}
\item Qt
\item Boost
\item Armadillo
\item mlpack
\end{DoxyItemize}

If there is a compelling reason to use a different library than the ones listed above, please discuss it with us using the issues tab before you start writing code. Any library that is to be used in \hyperlink{namespace_vespucci}{Vespucci} must be regularly built and tested on Windows 7 (using M\+S\+VC and G\+CC), Mac OS 10.\+7 (Using clang), and Ubuntu 14.\+04 L\+TS (or a similar G\+N\+U/\+Linux distro, using G\+CC). If the library is not regularly tested on one of these platforms, and there is compelling reason to do so, we will set-\/up regular testing using Travis-\/\+CI and or Appveyor. As Vesucci is distributed under the terms of the G\+PL, any additional library used must use a license acceptable for G\+PL software.

\section*{Code Style }

\subsection*{Style Guides }

\hyperlink{namespace_vespucci}{Vespucci} tries to adhere to the \href{https://google.github.io/styleguide/cppguide.html}{\tt Google C++ Style Guide}. However, none of the libraries \hyperlink{namespace_vespucci}{Vespucci} links to follow this guide. Armadillo uses underscore\+\_\+case for all names and mlpack and Qt use camel\+Case for all names. The following exceptions (and perhaps others) apply\+:
\begin{DoxyItemize}
\item Source files take the extension {\ttfamily .cpp}
\item Member functions that call their member\textquotesingle{}s member functions take the same style as their member\textquotesingle{}s member function (e.\+g. if we write a function in a {\ttfamily Q\+Dialog} class that calls the {\ttfamily add\+Graph} member of a {\ttfamily \hyperlink{class_q_custom_plot}{Q\+Custom\+Plot}} object, we name the member of the {\ttfamily Q\+Dialog} \char`\"{}`add\+Graph()`\char`\"{}, rather than the stylistically preferred \char`\"{}`\+Add\+Graph()`\char`\"{}).
\end{DoxyItemize}

\subsection*{Names }


\begin{DoxyItemize}
\item Both member functions and functions that do not belong to a class are named in Pascal\+Case, unless they are getters.
\item Member variables are denoted in underscore\+\_\+case, with a trailing underscore (e.\+g. {\ttfamily name\+\_\+}, {\ttfamily spectra\+\_\+}, etc).
\item Variables that are not members are denoted in underscore\+\_\+case.
\item Setters are named in Pascal\+Case like other functions, but are named after the variables they set (e.\+g. {\ttfamily Set\+Name()} for the setter of the {\ttfamily name\+\_\+} member).
\item Getters are named after the member they return (e.\+g. the getter for {\ttfamily abscissa\+\_\+} is named {\ttfamily abscissa()}). Getters that return pointers to members have {\ttfamily \+\_\+ptr} appended to the end of their names. Where getters that return copies and getters that return references both exist, the getter that returns the reference is named with {\ttfamily \+\_\+ref} appended.
\item Every function belongs to a namespace, either the namespace of its parent class or a namespace like {\ttfamily \hyperlink{namespace_vespucci_1_1_math}{Vespucci\+::\+Math}} or {\ttfamily Binary\+Import}.
\item Widgets in Qt forms are named using Qt style inside .ui files, but use our style inside C++ classes (e.\+g. {\ttfamily name\+Line\+Edit} becomes {\ttfamily name\+\_\+line\+\_\+edit\+\_\+}). The type of the widget should be included in the name.
\item As mentioned above, an exception exists for a function whose sole purpose is to call the member of one of the class\textquotesingle{}s members.
\end{DoxyItemize}

\subsection*{Types }

Variables in \hyperlink{namespace_vespucci}{Vespucci} should use the following types\+:
\begin{DoxyItemize}
\item Numeric data should use armadillo types whenever possible.
\item Data to be displayed to the user should use Qt types whenever possible, converting them to standard library types only when necessary.
\item If a variable is expected to be unsigned, it should use an unsigned type.
\end{DoxyItemize}

\section*{Adding Processing Methods to \hyperlink{namespace_vespucci}{Vespucci} }

To add a processing method to \hyperlink{namespace_vespucci}{Vespucci}, the following must be done\+:
\begin{DoxyItemize}
\item A member function must be added to {\ttfamily \hyperlink{class_vespucci_dataset}{Vespucci\+Dataset}} to execute the analysis.
\item If the method requires more than 5 lines of code, a function performing the method must be included in the {\ttfamily \hyperlink{namespace_vespucci_1_1_math}{Vespucci\+::\+Math}} namespace in the \hyperlink{namespace_vespucci}{Vespucci} library.
\item A form class subclassed from {\ttfamily Q\+Dialog} must be created, or an existing dialog expanded to handle the new method.
\end{DoxyItemize}

\subsection*{Processing G\+UI Classes }

If a class already exists for performing a processing step substantially similar to the method to be added, the existing class should be expanded by the addition of widgets to handle user input. Widgets may also simply be reused with their {\ttfamily Q\+Label}s changed. If a new form class must be created, follow the same procedure as you would for a new analysis form class, documented in the subsection \char`\"{}\+Analysis G\+U\+I Classes\char`\"{} of the section \char`\"{}\+Adding Analysis Methods to Vespucci\char`\"{}.

\section*{Adding Analysis Methods to \hyperlink{namespace_vespucci}{Vespucci} }

To add an analysis method to \hyperlink{namespace_vespucci}{Vespucci}, the following must be done\+:
\begin{DoxyItemize}
\item A member function must be added to {\ttfamily \hyperlink{class_vespucci_dataset}{Vespucci\+Dataset}} to execute the analysis. This member must take {\ttfamily Q\+String name} as its first parameter.
\item If a method has not yet been implemented in mlpack, a function to execute the analysis must be created in the {\ttfamily \hyperlink{namespace_vespucci_1_1_math}{Vespucci\+::\+Math}} namespace of the Vespucci\+Library.
\item A class must be created to handle data generated by the analysis, unless mlpack has already done this.
\item If a method is already implemented in mlpack, the {\ttfamily \hyperlink{class_analysis_results}{Analysis\+Results}} may be constructed in the {\ttfamily \hyperlink{class_vespucci_dataset}{Vespucci\+Dataset}} member function.
\item A form class subclassed from {\ttfamily Q\+Dialog} to allow the user to enter parameters.
\end{DoxyItemize}

\subsection*{Analysis G\+UI Classes }

G\+UI classes to handle the input of parameters from the user must have the following\+:
\begin{DoxyItemize}
\item A constructor which takes the current {\ttfamily Q\+Model\+Index} from dataset tree view and obtains a {\ttfamily Q\+Shared\+Pointer$<$\hyperlink{class_vespucci_dataset}{Vespucci\+Dataset}$>$} to the dataset the analysis is to be performed on, and calls {\ttfamily find\+Child} on the required {\ttfamily Q\+Widget} members.
\item A member called {\ttfamily data\+\_\+} or {\ttfamily dataset\+\_\+} which contains a {\ttfamily Q\+Shared\+Pointer$<$\hyperlink{class_vespucci_dataset}{Vespucci\+Dataset}$>$} corresponding to the active dataset.
\item Pointers to the appropriate {\ttfamily Q\+Widget}s that interact with the user.
\item Correct names for the widgets. A {\ttfamily Q\+Widget} that is called \char`\"{}thing\+Widget\char`\"{} in the .ui file should have a pointer named {\ttfamily thing\+\_\+widget\+\_\+} in the class. Widgets are named in the conventional Qt style within forms, but in Google-\/esque style within the C++ classes. The base type of the widget must be included in the name (e.\+g. {\ttfamily name\+\_\+line\+\_\+edit\+\_\+} for the {\ttfamily Q\+Line\+Edit} object that takes string representing a name from a user).
\end{DoxyItemize}

\subsection*{{\ttfamily \hyperlink{class_vespucci_dataset}{Vespucci\+Dataset}} member functions }

Member functions to perform an analysis must do the following\+:
\begin{DoxyItemize}
\item Take the name of the object to display to the user and use as a key in {\ttfamily analysis\+\_\+results\+\_\+}.
\item Perform the analysis through a class designed to handle the analysis (either bespoke or included from mlpack)
\item Add a {\ttfamily Q\+Shared\+PointeR$<$\hyperlink{class_analysis_results}{Analysis\+Results}$>$} object to {\ttfamily analysis\+\_\+results\+\_\+} map containing the matrices generated by the analysis. This is obtained from the {\ttfamily Get\+Data()} method of the analysis handler or is initialized in the {\ttfamily \hyperlink{class_vespucci_dataset}{Vespucci\+Dataset}} member in the case of analysis methods implemented by mlpack.
\end{DoxyItemize}

\subsection*{Classes to Handle Analysis Data }

A {\ttfamily \hyperlink{class_vespucci_dataset}{Vespucci\+Dataset}} contains all analysis methods that may be called on it. Each analysis has a helper object which takes the data as a reference from the dataset. Helper objects must implement the following members\+:
\begin{DoxyItemize}
\item A constructor which takes the name of the result and relevant metadata
\item Private members of {\ttfamily arma\+::mat} type which store the results of the analysis. It is customary to use the member {\ttfamily results\+\_\+} when a matrix is returned from an analysis function, and to name these members the same as the parameters of the analysis function (remembering to add the trailing underscore used for members in \hyperlink{namespace_vespucci}{Vespucci}).
\item A method called {\ttfamily Apply()} to which is passed {\ttfamily spectra\+\_\+} and perhaps {\ttfamily abscissa\+\_\+}, along with the parameters of the analysis that are taken in the {\ttfamily \hyperlink{class_vespucci_dataset}{Vespucci\+Dataset}} analysis member function. This function calls the functions from the \hyperlink{namespace_vespucci}{Vespucci} library that are required for the analysis.
\item A method called {\ttfamily Get\+Data()}, which heap-\/allocates an {\ttfamily \hyperlink{class_analysis_results}{Analysis\+Results}} object in a {\ttfamily Q\+Shared\+Pointer} and calls the {\ttfamily Append\+Result()} method of the {\ttfamily \hyperlink{class_analysis_results}{Analysis\+Results}} object to add matrices. Each matrix should have name that constitutes a unique key, and if necessary, column headings should be provided in a {\ttfamily Q\+String\+List} for at least the first 15 columns of each matrix.
\end{DoxyItemize}

\subsection*{Analysis Functions in the {\ttfamily \hyperlink{namespace_vespucci_1_1_math}{Vespucci\+::\+Math}} Namespace }

Analysis methods must be implemented in either mlpack or armadillo, or in the {\ttfamily \hyperlink{namespace_vespucci_1_1_math}{Vespucci\+::\+Math}} namespace. A few style rules apply to this namespace that do not apply to \hyperlink{namespace_vespucci}{Vespucci} in general\+:
\begin{DoxyItemize}
\item All matrices on which operations are to be performed are to be taken as constant references {\ttfamily const arma\+::mat\&}. If the matrix itself is to be modified, the function should return a copy or include a copy as a non-\/{\ttfamily const} reference parameter.
\item The {\ttfamily using} directive should not to be used so as to avoid confusion between functions in the {\ttfamily std} and {\ttfamily arma} namespaces.
\item To ease wrapping with other languages, Qt classes are to be avoided. The equivalent C++ standard library class should be used instead (e.\+g. {\ttfamily std\+::string} instead of {\ttfamily Q\+String}). This is in contrast to the \hyperlink{namespace_vespucci}{Vespucci} G\+UI program, where Qt types are preferred.
\item Armadillo, Boost, and the standard library are the only libraries that may be used. This is intended to make the code readable by users who are only familiar with languages like M\+A\+T\+L\+AB.
\item Unit tests must be written using the Boost unit test framework.
\item Functions that check for success must have return values of type {\ttfamily bool}.
\item Each analysis that operates on single spectra must include a function that takes a single spectrum and a function that takes a column-\/major matrix of spectra. The function that takes a matrix will have the same name as the function that takes a vector, but with {\ttfamily Mat} appended to the end of the function name (e.\+g. {\ttfamily Quantify\+Peak} and {\ttfamily Quantify\+Peak\+Mat}, where {\ttfamily Quantify\+Peak} returns a {\ttfamily arma\+::rowvec} and {\ttfamily Quantify\+Peak\+Mat} returns an {\ttfamily arma\+::mat}).
\item If a matrix is expected to contain only one column, the {\ttfamily arma\+::vec} type should be used. If a matrix is expected to contain only one row, {\ttfamily arma\+::rowvec} type should be used.
\item If a value is expected to be unsigned, use {\ttfamily arma\+::uword} for integers and {\ttfamily unsigned double} for floating-\/point numbers.
\item Any function that can throw an exception should be inside of a {\ttfamily try/catch} block. The {\ttfamily catch} block must write the function call that threw the exception to {\ttfamily stdout} and throw the same exception again.
\item A function returning a matrix with more than one column for each spectrum should include these matrices in an {\ttfamily arma\+::field$<$arma\+::mat$>$} type.
\item Each function should be defined in a file with the same name as the header it is declared in and each type of analysis should include its own header and source file.
\item The use of C++11 features is highly recommended when they reduce the complexity of the code.
\end{DoxyItemize}

\section*{Writing Tests }

All methods in the \hyperlink{namespace_vespucci}{Vespucci} library are unit tested to ensure code quality and reproducibility of results. The project located in the Test folder is used to run all unit tests on math functions. Example datasets are provided, including real-\/world and generated spectra. Unit tests written for functions in the \hyperlink{namespace_vespucci}{Vespucci} library should use the Boost unit test framework. Tests written for Qt classes should use Qt\+Test. Some methods, such as Vertex Components Analysis are untestable as they produce different results each time they are run on the same data. These functions should only be tested for the validity of their output, not for the values. 